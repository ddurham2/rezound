
--- THINGS TO DO FOR SURE ---

	- a newly recorded sound needs to be !saved
	- a new sounds need to be !saved

	- use a registry setting for knowing where to put working files and the clipboard instead of always /tmp

	- When it's possible, I really need to do something different in TPoolFile::isExclusiveLocked and also TPoolFile::getSharedLockCount because right now, the isExclusiveLocked returns true if it's shared locked obviously because the tryLock fails so it assumes wrongly that there's an exclusive lock obtained

	- warn the user if he's saving an exported file format and information such as cues and user notes will not be exported (for now)
		- problem should somewhat go away with a different audio file library

	- rename MAX_CHANNELS and MAX_LENGTH in ASound.h to something a little more ReZound specific like REZ_MAX_CHANNELS REZ_MAX_LENGTH

	- change the ClipSample macro to an inline function so _SSS is no longer a static global... verify that the assembler for the inline is no less efficient than the macro

	- I need to go thru these backend classes and make sure of what they all do... 
		- I have the concept that a sound can be loaded that does have a window: i.e. it's been registered with CSoundManager but not thru ASoundFileManager
		- I should think thru just exactly what my requirements are and base the classes on that... I shouldn't have to rewrite much code.. it's all there

			- ASoundPlayer plays CSoundPlayerChannels (perhaps change the name from Channel to Track so as not to confuse it with the channels of PCM data)
			- CSoundManager managers CSoundManagerClients... Now, just WHY is this necessary?  So I can have one sound loaded assigned to many CSoundPlayerTracks
		- I think my motives were to be able to implement MIDISamplePlayer with most of ReZound's code, but a different front end
			- while this may be feasible, I also need to think thru how multitrack editing may be accomplished... Perhaps it already can

		- I just don't have a good grip that there is a reason for everything I did in the backend as far as these managers... 

	- When pasting data, there is no heeding of the differences in sample rate of the src data when pasting to the destination
		- I should fix this problem when I implement a real clipboard system and I would have to supply the PCM parameters to the clipboard when I copied the data there, then pasting could do something to resolve any differances when reading from it

	- the clip board that the edit actions use is not set up to allow it to paste and copy from other applications
		- when/if I want to allow that, I should create a base class clipboard which has the platform specific
		  implementation that reads from the system clipboard.
		- this base class would probably have some sort of accesser class with a operator[] defined because I need
		  to support all the mixing methods when pasting...

	- need to make 'add channel' and remove channel actions so I can test more than stereo number of channels... 
		- DONE (but no frontend control yet): when I do implement the more than 2 channels, I need to have a way to route the multiple channels of a sound to the 2 (or more) channels of sound card output
		- DONE the default (when a sound is loaded) should be just to assign each channel to the lesser number of sound card channels in a rotating fashion
		- DONE the routing should be assigned per CSoundPlayerChannel object, but the routing information should also be saved in a pool in the sound object


	- use progress bars when doing TPoolAccesser::copyData and TPoolAccesser::zeroData 
		- PoolFile::copyToFile is still without a progress bar

	- I need to eventually handle command line arguments.
		- I should implement handling them in the backend so that I wouldn't have to reimplement parsing them for each frontend.
		- I need to check that when I pass argv to fox's initialize function that it either does or does not remove the X arguments.
		- --help should be detected by all processers of command line arguement and add to the stdout the arguments that they handle.
		- I suppose I should use popt because it is packaged for most all rpm abd deb based distros.. I need to find URL of popt's homepage and refer to that on error in configure

	- I need to think thru and handle problems with the data becoming too large for whatever address space is currently active
		- if ASound is about to change the space, if the total space is about to cross some threshhold, I shouldn't proceed to do the action

	- need to eventually use a different sound file library which can also retrieve and store arbitrary data sections in the formats that support it (namely .wav).. So I can store and load cues
		- I'd like to use libst (lib form of SOX), but there is no documentation or common API I don't think

	- Need to handle duplicate named cues when loading a file.. I don't allow them, but a file format might

	- Truncate file formats that don't save more than 32bits worth of sound and the sound file is longer than that



--- POSSIBLE THINGS TO DO ---

	- To speed up initial work upon loading a large file (>100mb) I could have the loading functions calculate the peak chunk info instead of loading then calcing the peak chunk on the first draw which causes it to have to read and write the data twice instead of once

	- The only reason I don't prebuffer more data than I do is because the play position drawn in the front end is always a little ahead of the acutal playing sound... I could buffer a lot of data if I were to know the approximate delay time of processing to sound card I might be able to overcome the problem...
		- One possibility is to be able to know which buffer is playing, then I could tag each buffer with a play position for the start of that buffer... then I would just render the play position on screen as the start position of the currently playing buffer
		- Right now, if I play a bunch of sounds and run top, each time top updates it causes a break in the sound.  This shouldn't happen though if I were to prebuffer more data, I only need to over come the play position problem.  Perhaps there is a schedule that the play position could be on, each time a buffer is mixed it records a rather precise time-of-day and each time them method is called that asks for the play position it knows how much time has passed since then and returns where it should be playing... There would be a problem with positions after a loop point, but perhaps I could keep a list of times when the loop point should have been crossed and factor in those times


	- This is partially complete... I could go further to do it to all actions possible (for the realtime value later)
		- I could make the noise-gate/exciter(done) and compresser/limiter(doesn't exist yet) CDSPBlocks so their abilities would be easily used in other effects
			- Plus, it would be possible to use in realtime applications eventually
			- I could do the same for the rate change (I could construct the CDSPBlock with the graph parameter object, and the length of the sound)
				 - DONE: Except for the performance hit of virtual functions or pointers to functions in the algorithm, I could create an LFO object which some of the CDSP-blocks could use... Constant LFOs would exist, and an LFO for the CGraphParameterNodes (given a length until repeat) could be given
				 - (I did this already and the performance hit was actually quite acceptable)
			- The same could go for CChangeAmplitudeRate, flange(done) and Echo(done) effect

	- It would seem profitable to merge CActionSound and CActionParameters into being the same class, since the sound, start and stop positions, and doChannels of CActionSound seem to also be parameters to the action
		- However, the reason I didn't do this right away, was because I thought that someday I might want to stream CActionParameters to disk and be able to recall it in the future to 
		  to do the action again with the same parameters.  But, the sound, stop and start positions, and doChannels of CActionSound would not be the same later, so I figured I should have one part of the parameters parameters that was fixed (CActionParameters) and one part that changes later (CActionSound)
		- Now, granted, there may be some parameters to actions within CActionParameters which don't necessarily work later on a different sound, namely any values which indicate positions within the sound or channel numbers within the sound... For these situations, I either should disallow this saving functionality make the parameters more relative to the sound not absolute








--- DONE ---

	- create ASound::moveData which we can use to more efficiently maintain undo copies
		- i.e. CChangeRateEffect should move the selection to an newly created undo pool, then add new space for the calculated data; upon undo, it should remove the space for the calculated data, then move from the undo pool back to the sound, then destroy the undo pool
		- I guess this means that an array or list of C...PoolAccessers should be passed to moveData, one for each channel that whichChannels is true for

		- i.e. CCropEdit should move the data before the selection to an undo pool, then the data after the selection to an undo pool

		- if I go thru each action and figure out how to do it, I should be able to create some general methods in ASound to manager the most common undo operations

		- Now using libaudiofile in anticipation of using sox's libst when it's more usable
			- support .wav format any better?
				- I should probably use libsndfile or SOX for loading and saving many more types of formats
			- support sample rates or bit rates other than what I have... Use either realtime conversion or alway convert to the native format when the sound is loaded

	- make a 'rotate' edit where 'X' samples from the beginning of the selection are moved to the end or X samples from the end are moved to the begginning... that is a left or right rotation

	- ASound::bits is probably on longer necessary since we don't support anything different than sample_t's type

	- NAH.... no need right now
		- split AAction.* into separate files for each class

	- CSoundPlayerChannel could be enhanced to read a mapping in ASound that maps each channel in the ASound with a channel in the player
		- ??? this is done, except there is no front-end interface to edit the mapping... by default all channels in a sound are assigned, left, right, left, right, etc...

	- I need to make the CSoundPlayerChannel heed the sample rate of the ASound object... I should just use linear interpolation of the playSpeed instead of the cheap aliased way of doing it... perhaps the audio hardware could be taken advantage of???

	- change rint to nearbyint since rint raises a math exception if it did rounding and should therefore be less efficient

	- cues within an ASound object with each having their own time index also need to be subject to adding and remove space.. 
		- any cue within the removed space needs to also be removed
		- any cue after added space needs to be shifted down by the amount of space added
		- and these times need to be restored if a actions is undo... Perhaps I could brute force, just save a copy of all the cues before an action is done, and restore this set of cues when an action is undo
			- this would not have serious memory requirements if the number of cues is relatively small... And I could do it all within AAction::doAction/undoAction and within the space modifier methods of ASound
		- actions should only affect cues if all the channels were affected

	- If I am to make selection changes actions, I should probably have a flag to AAciton which says not to lock the sounds for resize because 
		- both adding cues and selection changes would then cause hiccups in the sound if they are done while playing since a resize lock was unnessarily make on the data
		- I surely be a flag passed to AActionFactory's constructor

	- also, it may be benefitial to have a flag for each cue which says wether that cue is achored or not meaning it would move as the space changes within the sound or not
		- these would probably be a different color and/or symbol

	- Change CSoundPlayerChannel to do interpolation for sample rate conversion

